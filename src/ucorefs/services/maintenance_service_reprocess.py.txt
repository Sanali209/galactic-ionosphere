    async def reprocess_incomplete_embeddings(self) -> Dict[str, Any]:
        """
        Reprocess files that are marked INDEXED/COMPLETE but missing CLIP embeddings.
        
        This is a data integrity maintenance task that fixes files which progressed
        through the pipeline without proper embedding extraction.
        
        Returns:
            Dict with:
                files_found: Number of files missing embeddings
                files_reset: Number of files reset to REGISTERED state
                files_queued: Number of files queued for Phase 2
                errors: List of errors encountered
        """
        from src.ucorefs.models.file_record import FileRecord
        from src.ucorefs.models.base import ProcessingState
        from src.ucorefs.processing.pipeline import ProcessingPipeline
        import time
        
        start_time = time.time()
        result = {
            "files_found": 0,
            "files_reset": 0,
            "files_queued": 0,
            "duration": 0.0,
            "errors": []
        }
        
        try:
            logger.info("[MAINTENANCE_REPROCESS] Starting incomplete embeddings reprocessing...")
            
            # Find files claiming INDEXED/COMPLETE but no CLIP embeddings
            bad_files = await FileRecord.find({
                "processing_state": {"$gte": ProcessingState.INDEXED},
                "$or": [
                    {"embeddings.clip": {"$exists": False}},
                    {"embeddings": {}}
                ],
                "file_type": "image"  # Only images should have CLIP
            }).to_list()
            
            result["files_found"] = len(bad_files)
            logger.info(f"[MAINTENANCE_REPROCESS] Found {len(bad_files)} files missing CLIP embeddings")
            
            if not bad_files:
                result["duration"] = time.time() - start_time
                return result
            
            # Reset files to REGISTERED state and clear metadata
            file_ids = []
            for file in bad_files:
                try:
                    old_state = file.processing_state
                    file.processing_state = ProcessingState.REGISTERED
                    file.embeddings = {}
                    file.has_vector = False
                    await file.save()
                    
                    file_ids.append(file._id)
                    result["files_reset"] += 1
                    
                    logger.debug(f"[MAINTENANCE_REPROCESS] Reset {file.name}: {old_state.name} → REGISTERED")
                    
                except Exception as e:
                    error_msg = f"Failed to reset file {file._id}: {e}"
                    result["errors"].append(error_msg)
                    logger.error(f"[MAINTENANCE_REPROCESS] {error_msg}")
            
            # Requeue for Phase 2 processing
            if file_ids:
                try:
                    pipeline = self.locator.get_system(ProcessingPipeline)
                    await pipeline.enqueue_phase2(file_ids, force=True)
                    result["files_queued"] = len(file_ids)
                    
                    logger.info(f"[MAINTENANCE_REPROCESS] ✓ Queued {len(file_ids)} files for reprocessing")
                    
                except Exception as e:
                    error_msg = f"Failed to queue files for reprocessing: {e}"
                    result["errors"].append(error_msg)
                    logger.error(f"[MAINTENANCE_REPROCESS] {error_msg}")
            
            result["duration"] = time.time() - start_time
            logger.info(f"[MAINTENANCE_REPROCESS] Complete: {result['files_reset']} reset, {result['files_queued']} queued in {result['duration']:.2f}s")
            
        except Exception as e:
            result["errors"].append(f"Reprocessing failed: {e}")
            logger.error(f"[MAINTENANCE_REPROCESS] ✗ Failed: {e}")
        
        return result
